<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>QRÈÄ£Á∂ö„É™„Éº„ÉÄ„Éº</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Hiragino Sans",
          "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
        background: #0f172a;
        color: #e2e8f0;
      }
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 0;
        min-height: 100vh;
        min-height: -webkit-fill-available;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        overflow-x: hidden;
      }
      .container {
        width: 100%;
        min-height: 100vh;
        min-height: -webkit-fill-available;
        padding: 12px;
      }
      .card {
        width: 100%;
        max-width: 100%;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 12px;
        backdrop-filter: blur(10px);
      }
      h1 {
        margin: 0 0 8px;
        font-size: 18px;
        font-weight: 600;
        letter-spacing: 0.2px;
      }
      p {
        margin: 0 0 8px;
        color: #cbd5e1;
        font-size: 13px;
        line-height: 1.5;
      }
      .controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 10px;
      }
      button {
        border: 1px solid #334155;
        background: #1e293b;
        color: #e2e8f0;
        border-radius: 10px;
        padding: 10px 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 160ms ease;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }
      button:active {
        transform: scale(0.98);
        background: #334155;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .video-container {
        width: 100%;
        aspect-ratio: 4 / 3;
        max-height: 40vh;
        position: relative;
        border-radius: 12px;
        overflow: hidden;
        background: #0b1220;
        border: 1px solid rgba(255, 255, 255, 0.08);
        margin-bottom: 10px;
      }
      video {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      textarea {
        width: 100%;
        min-height: 120px;
        max-height: 200px;
        background: #0b1220;
        color: #e2e8f0;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        padding: 10px;
        font-family: ui-monospace, "SF Mono", Menlo, monospace;
        font-size: 13px;
        resize: vertical;
        -webkit-appearance: none;
      }
      .status {
        font-size: 12px;
        color: #94a3b8;
        min-height: 18px;
        padding: 4px 0;
      }
      .badges {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        margin-bottom: 8px;
      }
      .badge {
        padding: 4px 8px;
        border-radius: 999px;
        background: #1e293b;
        border: 1px solid rgba(255, 255, 255, 0.08);
        font-size: 11px;
        color: #cbd5e1;
        white-space: nowrap;
      }
      .panel {
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        padding: 8px;
        margin-top: 8px;
      }
      .panel h3 {
        margin: 0 0 6px;
        font-size: 13px;
        font-weight: 600;
        color: #e2e8f0;
      }
      .progress-list {
        font-size: 12px;
        color: #cbd5e1;
        line-height: 1.4;
      }
      .progress-item {
        padding: 6px 8px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.06);
        word-wrap: break-word;
        overflow-wrap: break-word;
      }
      .progress-item div {
        margin: 2px 0;
        word-break: break-all;
      }
      .progress-item strong {
        color: #e2e8f0;
        font-weight: 600;
      }
      .recent {
        list-style: none;
        padding: 0;
        margin: 0;
        font-size: 11px;
        color: #94a3b8;
      }
      .recent li {
        padding: 5px 6px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.05);
        margin-bottom: 4px;
        word-break: break-all;
        overflow-wrap: break-word;
        line-height: 1.4;
      }
      
      /* „Çø„Éñ„É¨„ÉÉ„ÉàÂêë„ÅëË™øÊï¥ */
      @media (min-width: 641px) {
        .container {
          padding: 16px;
        }
        .card {
          max-width: 640px;
          margin: 0 auto;
          padding: 16px;
          border-radius: 18px;
        }
        h1 {
          font-size: 20px;
        }
        p {
          font-size: 14px;
        }
        .controls {
          grid-template-columns: repeat(4, 1fr);
        }
        button {
          padding: 11px 12px;
          font-size: 14px;
        }
        .video-container {
          max-height: 50vh;
        }
        textarea {
          min-height: 140px;
          font-size: 14px;
        }
      }
      
      /* „Éá„Çπ„ÇØ„Éà„ÉÉ„ÉóÂêë„ÅëË™øÊï¥ */
      @media (min-width: 1024px) {
        .container {
          padding: 24px;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .card {
          max-width: 960px;
          padding: 20px;
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
        }
        h1 {
          font-size: 22px;
          margin-bottom: 10px;
        }
        p {
          margin-bottom: 10px;
        }
        .controls {
          margin-bottom: 12px;
        }
        button {
          padding: 12px 14px;
          border-radius: 12px;
        }
        .video-container {
          max-height: 420px;
          margin-bottom: 12px;
        }
        textarea {
          min-height: 160px;
          padding: 12px;
          border-radius: 12px;
        }
      }
      
      /* Ê®™Âêë„ÅçË°®Á§∫„ÅÆÊúÄÈÅ©Âåñ */
      @media (orientation: landscape) and (max-height: 500px) {
        .container {
          padding: 8px;
        }
        h1 {
          font-size: 16px;
          margin-bottom: 4px;
        }
        p {
          display: none;
        }
        .video-container {
          max-height: 35vh;
        }
        textarea {
          min-height: 80px;
          max-height: 120px;
        }
        .panel {
          padding: 6px;
        }
      }
      
      /* QRÊ§úÁü•„Ç™„Éº„Éê„Éº„É¨„Ç§ */
      .detection-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
      }
      
      .detection-box {
        position: absolute;
        border: 3px solid #ef4444;
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(239, 68, 68, 0.6);
        animation: detectPulse 0.4s ease-out;
        pointer-events: none;
        background: rgba(239, 68, 68, 0.1);
      }
      
      @keyframes detectPulse {
        0% {
          transform: scale(0.8);
          opacity: 0;
          border-color: #ef4444;
          box-shadow: 0 0 0 rgba(239, 68, 68, 0);
        }
        50% {
          transform: scale(1.1);
          opacity: 1;
          border-color: #ef4444;
          box-shadow: 0 0 30px rgba(239, 68, 68, 0.8);
        }
        100% {
          transform: scale(1);
          opacity: 0.8;
          border-color: #ef4444;
          box-shadow: 0 0 15px rgba(239, 68, 68, 0.4);
        }
      }
      
      @keyframes lineGlow {
        0% {
          opacity: 0;
          filter: blur(2px);
        }
        50% {
          opacity: 1;
          filter: blur(0);
          box-shadow: 0 0 20px rgba(255, 59, 88, 1);
        }
        100% {
          opacity: 0.8;
          filter: blur(0);
          box-shadow: 0 0 10px rgba(255, 59, 88, 0.6);
        }
      }
      
      @keyframes pathPulse {
        0% {
          opacity: 0;
          stroke-width: 1;
        }
        50% {
          opacity: 1;
          stroke-width: 4;
        }
        100% {
          opacity: 0.8;
          stroke-width: 3;
        }
      }
      
      @keyframes boxPulse {
        0% {
          transform: scale(0.9);
          opacity: 0;
        }
        50% {
          transform: scale(1.05);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 0.8;
        }
      }
      
      /* „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº */
      .progress-bar-container {
        width: 100%;
        height: 24px;
        background: #0b1220;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        overflow: hidden;
        margin: 10px 0;
        position: relative;
      }
      
      .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #3b82f6 0%, #10b981 100%);
        border-radius: 12px;
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        min-width: 40px;
      }
      
      .progress-bar::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          90deg,
          transparent 0%,
          rgba(255, 255, 255, 0.2) 50%,
          transparent 100%
        );
        animation: shimmer 2s infinite;
      }
      
      @keyframes shimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }
      
      .progress-text {
        font-size: 11px;
        color: #ffffff;
        font-weight: 600;
        z-index: 1;
        position: relative;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      }
      
      .progress-info {
        font-size: 11px;
        color: #94a3b8;
        text-align: center;
        margin-top: 4px;
      }
      
      /* Ê§úÁü•ÊàêÂäü„ÅÆÈÄöÁü• */
      .detection-toast {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #10b981;
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 600;
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        animation: toastIn 0.3s ease-out;
        z-index: 100;
      }
      
      @keyframes toastIn {
        0% {
          transform: translateX(-50%) translateY(-20px);
          opacity: 0;
        }
        100% {
          transform: translateX(-50%) translateY(0);
          opacity: 1;
        }
      }
      
      /* „ÉÄ„Éº„ÇØ„É¢„Éº„ÉâÂØæÂøú */
      @media (prefers-color-scheme: light) {
        :root {
          background: #f8fafc;
          color: #1e293b;
        }
        body {
          background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
        }
        .card {
          background: rgba(255, 255, 255, 0.9);
          border: 1px solid rgba(0, 0, 0, 0.1);
        }
        button {
          background: #f8fafc;
          border: 1px solid #cbd5e1;
          color: #1e293b;
        }
        button:active {
          background: #e2e8f0;
        }
        textarea {
          background: #ffffff;
          color: #1e293b;
          border: 1px solid #cbd5e1;
        }
        .video-container {
          background: #f1f5f9;
          border: 1px solid #cbd5e1;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="card">
        <h1>QRÈÄ£Á∂ö„É™„Éº„ÉÄ„Éº</h1>
        <p>„Ç´„É°„É©„Å´QR„Ç≥„Éº„Éâ„Çí„Åã„Åñ„Åó„Å¶ÈÄ£Á∂öË™≠„ÅøÂèñ„Çä</p>
        <div class="badges">
          <span id="mode" class="badge">„É¢„Éº„Éâ: Êú™ÈñãÂßã</span>
          <span id="capability" class="badge">Ê§úÂá∫Âô®: Á¢∫Ë™ç‰∏≠‚Ä¶</span>
        </div>
        <div class="controls">
          <button id="start">ÈñãÂßã</button>
          <button id="stop" disabled>ÂÅúÊ≠¢</button>
          <button id="clear">„É™„Çª„ÉÉ„Éà</button>
          <button id="copy">„Ç≥„Éî„Éº</button>
        </div>
        <div class="video-container">
          <video id="video" autoplay muted playsinline></video>
          <div class="detection-overlay" id="detectionOverlay"></div>
        </div>
        <div class="progress-bar-container">
          <div class="progress-bar" id="progressBar" style="width: 0%">
            <span class="progress-text" id="progressText">0%</span>
          </div>
        </div>
        <div class="progress-info" id="progressInfo">QR„Ç≥„Éº„Éâ„Çí„Ç´„É°„É©„Å´Âêë„Åë„Å¶„Åè„Å†„Åï„ÅÑ</div>
        <textarea
          id="output"
          placeholder="Ë™≠„ÅøÂèñ„Å£„ÅüQR„Éá„Éº„Çø„Åå„Åì„Åì„Å´Ë°®Á§∫„Åï„Çå„Åæ„Åô"
          spellcheck="false"
          readonly
        ></textarea>
        <div class="panel">
          <h3>ÈÄ≤Êçó</h3>
          <div id="progress" class="progress-list">Êú™Âèó‰ø°</div>
        </div>
        <div class="panel">
          <h3>Áõ¥Ëøë„ÅÆQR</h3>
          <ul id="recent" class="recent">
            <li>„Åæ„Å†Âèó‰ø°„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì</li>
          </ul>
        </div>
        <div class="status" id="status">Ê∫ñÂÇôÂÆå‰∫Ü</div>
      </div>
    </div>

    <canvas id="hidden-canvas" width="640" height="360" style="display: none"></canvas>
    <script>
      const videoEl = document.getElementById("video");
      const outputEl = document.getElementById("output");
      const statusEl = document.getElementById("status");
      const modeBadge = document.getElementById("mode");
      const capabilityBadge = document.getElementById("capability");
      const progressEl = document.getElementById("progress");
      const recentEl = document.getElementById("recent");
      const canvas = document.getElementById("hidden-canvas");
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      const detectionOverlay = document.getElementById("detectionOverlay");
      const progressBar = document.getElementById("progressBar");
      const progressText = document.getElementById("progressText");
      const progressInfo = document.getElementById("progressInfo");

      const startBtn = document.getElementById("start");
      const stopBtn = document.getElementById("stop");
      const clearBtn = document.getElementById("clear");
      const copyBtn = document.getElementById("copy");

      let stream;
      let detector;
      let running = false;
      const seenRaw = new Set();
      let session = null;
      const recentItems = [];

      // Ê§úÁü•Êû†„Çí„Ç≥„Éº„Éä„ÉºÂ∫ßÊ®ô„Å´Ê≤ø„Å£„Å¶ÊèèÁîªÔºàË§áÊï∞ÂêåÊôÇÂØæÂøúÔºâ
      function drawDetectionOverlay(detections) {
        detectionOverlay.innerHTML = "";
        if (!detections || !detections.length || !videoEl.videoWidth) return;

        const videoRect = videoEl.getBoundingClientRect();
        const scaleX = videoRect.width / videoEl.videoWidth;
        const scaleY = videoRect.height / videoEl.videoHeight;

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", "100%");
        svg.setAttribute("height", "100%");
        svg.style.position = "absolute";
        svg.style.inset = "0";
        svg.style.pointerEvents = "none";

        detections.forEach((det) => {
          let corners = det.corners;
          if (!corners || corners.length < 4) {
            // cornerPoints„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Éê„Ç¶„É≥„Éá„Ç£„É≥„Ç∞„Éú„ÉÉ„ÇØ„Çπ„Åã„ÇâÁîüÊàê
            const box = det.box;
            if (!box) return;
            corners = [
              { x: box.x, y: box.y },
              { x: box.x + box.width, y: box.y },
              { x: box.x + box.width, y: box.y + box.height },
              { x: box.x, y: box.y + box.height },
            ];
          }
          const pts = corners
            .slice(0, 4)
            .map((p) => `${p.x * scaleX},${p.y * scaleY}`)
            .join(" L ");

          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          path.setAttribute("d", `M ${pts} Z`);
          path.setAttribute("fill", "rgba(255, 59, 88, 0.12)");
          path.setAttribute("stroke", "#ff3b58");
          path.setAttribute("stroke-width", "3");
          path.style.filter = "drop-shadow(0 0 10px rgba(255, 59, 88, 0.8))";
          path.style.animation = "pathPulse 0.45s ease-out";
          svg.appendChild(path);
        });

        detectionOverlay.appendChild(svg);
      }

      // Ê§úÁü•Èü≥„ÇíÂÜçÁîü
      function playDetectionSound() {
        // Web Audio API„ÅßÁ∞°Âçò„Å™„Éî„Ç≥„Éº„É≥Èü≥„ÇíÁîüÊàê
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(2000, audioContext.currentTime + 0.1);
          
          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
          
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.2);
        } catch (e) {
          console.log("Èü≥Â£∞ÂÜçÁîü„Ç®„É©„Éº:", e);
        }
      }
      
      // „Éà„Éº„Çπ„ÉàÈÄöÁü•
      function showToast(message) {
        const toast = document.createElement("div");
        toast.className = "detection-toast";
        toast.textContent = message;
        document.body.appendChild(toast);
        
        setTimeout(() => {
          toast.style.opacity = "0";
          toast.style.transform = "translateX(-50%) translateY(-20px)";
          setTimeout(() => toast.remove(), 300);
        }, 1500);
      }
      
      // „Éó„É≠„Ç∞„É¨„Çπ„Éê„ÉºÊõ¥Êñ∞
      function updateProgressBar() {
        if (!session) {
          progressBar.style.width = "0%";
          progressText.textContent = "0%";
          progressInfo.textContent = "QR„Ç≥„Éº„Éâ„Çí„Ç´„É°„É©„Å´Âêë„Åë„Å¶„Åè„Å†„Åï„ÅÑ";
          return;
        }
        
        const { total, received } = session;
        const percentage = Math.round((received.size / total) * 100);
        progressBar.style.width = `${percentage}%`;
        progressText.textContent = `${percentage}%`;
        
        if (percentage === 100) {
          progressInfo.textContent = "‚úÖ ÂÆåÊàêÔºÅÂÖ®„ÉÅ„É£„É≥„ÇØÂèó‰ø°ÂÆå‰∫Ü";
          progressBar.style.background = "linear-gradient(90deg, #10b981 0%, #22c55e 100%)";
        } else {
          progressInfo.textContent = `Ë™≠„ÅøÂèñ„Çä‰∏≠: ${received.size}/${total} „ÉÅ„É£„É≥„ÇØ`;
          progressBar.style.background = "linear-gradient(90deg, #3b82f6 0%, #10b981 100%)";
        }
      }

      const fallbackDecoder = (imageData) =>
        window.jsQR && window.jsQR(imageData.data, imageData.width, imageData.height);

      async function setupDetector() {
        if (!("BarcodeDetector" in window)) {
          capabilityBadge.textContent = "Ê§úÂá∫Âô®: jsQR";
          await loadJsQR();
          return;
        }
        const formats = await BarcodeDetector.getSupportedFormats();
        if (formats.includes("qr_code")) {
          detector = new BarcodeDetector({ formats: ["qr_code"] });
          capabilityBadge.textContent = "Ê§úÂá∫Âô®: „Éç„Ç§„ÉÜ„Ç£„Éñ";
        } else {
          capabilityBadge.textContent = "Ê§úÂá∫Âô®: jsQR";
          await loadJsQR();
        }
      }

      function loadJsQR() {
        return new Promise((resolve, reject) => {
          if (window.jsQR) return resolve();
          const script = document.createElement("script");
          script.src = "https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js";
          script.onload = () => resolve();
          script.onerror = reject;
          document.head.appendChild(script);
        });
      }

      async function start() {
        if (running) return;
        try {
          await setupDetector();
          stream = await navigator.mediaDevices.getUserMedia({
            video: { 
              facingMode: "environment",
              width: { ideal: 1280 },
              height: { ideal: 720 }
            },
            audio: false,
          });
          videoEl.srcObject = stream;
          running = true;
          startBtn.disabled = true;
          stopBtn.disabled = false;
          modeBadge.textContent = "„É¢„Éº„Éâ: „Çπ„Ç≠„É£„É≥‰∏≠";
          status("„Ç´„É°„É©ÈñãÂßã");
          requestAnimationFrame(tick);
        } catch (err) {
          status("„Ç´„É°„É©„Ç®„É©„Éº: " + err.message);
        }
      }

      function stop() {
        running = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        modeBadge.textContent = "„É¢„Éº„Éâ: ÂÅúÊ≠¢";
        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
          stream = null;
        }
        videoEl.srcObject = null;
        detectionOverlay.innerHTML = "";
      }

      function clearOutput() {
        outputEl.value = "";
        seenRaw.clear();
        session = null;
        recentItems.length = 0;
        detectionOverlay.innerHTML = "";
        renderRecent();
        renderProgress();
        updateProgressBar();
        status("„ÇØ„É™„Ç¢„Åó„Åæ„Åó„Åü");
      }

      async function tick() {
        if (!running || videoEl.readyState < 2) {
          if (running) requestAnimationFrame(tick);
          return;
        }

        // „Ç´„É°„É©Êò†ÂÉè„Çí„Ç≠„É£„É≥„Éê„Çπ„Å´ÊèèÁîª
        const vw = videoEl.videoWidth;
        const vh = videoEl.videoHeight;
        
        if (vw && vh) {
          canvas.width = vw;
          canvas.height = vh;
          ctx.drawImage(videoEl, 0, 0, vw, vh);

          if (detector) {
            try {
              const results = await detector.detect(canvas);
              if (results.length > 0) {
                const detections = results.map((r) => ({
                  raw: r.rawValue,
                  corners: r.cornerPoints || null,
                  box: r.boundingBox || null,
                }));
                drawDetectionOverlay(detections);
                handleResults(detections);
              } else {
                drawDetectionOverlay([]);
              }
            } catch (err) {
              console.error("Ê§úÂá∫„Ç®„É©„Éº:", err);
            }
          } else if (window.jsQR) {
            const imageData = ctx.getImageData(0, 0, vw, vh);
            const code = jsQR(imageData.data, imageData.width, imageData.height, {
              inversionAttempts: "dontInvert"
            });
            if (code && code.data && code.location) {
              const detections = [{
                raw: code.data,
                corners: [
                  code.location.topLeftCorner,
                  code.location.topRightCorner,
                  code.location.bottomRightCorner,
                  code.location.bottomLeftCorner,
                ],
                box: {
                  x: code.location.topLeftCorner.x,
                  y: code.location.topLeftCorner.y,
                  width: code.location.topRightCorner.x - code.location.topLeftCorner.x,
                  height: code.location.bottomLeftCorner.y - code.location.topLeftCorner.y,
                },
              }];
              drawDetectionOverlay(detections);
              handleResults(detections);
            } else {
              drawDetectionOverlay([]);
            }
          }
        }

        requestAnimationFrame(tick);
      }

      function handleResults(detections) {
        if (!detections.length) return;
        let newChunks = 0;
        let hasNewData = false;
        
        detections.forEach((det) => {
          const trimmed = (det.raw || "").trim();
          if (!trimmed) return;
          
          const parsed = parseChunk(trimmed);
          if (!parsed) return;
          
          // Êñ∞„Åó„ÅÑ„ÉÅ„É£„É≥„ÇØ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
          const chunkKey = `${parsed.messageId}-${parsed.index}`;
          const isNewChunk = !seenRaw.has(chunkKey);
          
          if (isNewChunk) {
            seenRaw.add(chunkKey);
            hasNewData = true;
            playDetectionSound();
            
            session = mergeChunk(session, parsed);
            newChunks += 1;
            addRecent(trimmed, parsed);
          }
        });
        
        if (hasNewData) {
          maybeRender(session);
          updateProgressBar();
          if (newChunks) status(`Êñ∞Ë¶è ${newChunks} „ÉÅ„É£„É≥„ÇØËøΩÂä†`);
        }
      }

      function parseChunk(raw) {
        const parts = raw.split("|");
        if (parts.length !== 5) return null;
        const [prefix, version, messageId, chunkPart, b64] = parts;
        if (prefix !== "QRCHUNK" || version !== "v1") return null;
        const [idxStr, totalStr] = chunkPart.split("/");
        const index = Number(idxStr);
        const total = Number(totalStr);
        if (!Number.isInteger(index) || !Number.isInteger(total)) return null;
        if (index < 0 || total <= 0 || index >= total) return null;
        return { messageId, index, total, b64 };
      }

      function mergeChunk(current, chunk) {
        if (!current || current.messageId !== chunk.messageId) {
          return {
            messageId: chunk.messageId,
            total: chunk.total,
            received: new Map([[chunk.index, chunk.b64]]),
          };
        }
        if (current.total !== chunk.total) return current;
        if (!current.received.has(chunk.index)) {
          current.received.set(chunk.index, chunk.b64);
        }
        return current;
      }

      function maybeRender(sess) {
        if (!sess) return;
        const { total, received } = sess;
        if (received.size !== total) {
          status(`Âèó‰ø° ${received.size}/${total}`);
          renderProgress();
          updateProgressBar();
          return;
        }
        const b64url = [];
        for (let i = 0; i < total; i += 1) {
          const v = received.get(i);
          if (typeof v !== "string") return;
          b64url.push(v);
        }
        const fullB64 = b64url.join("");
        const text = decodeBase64Url(fullB64);
        outputEl.value = text;
        status(`ÂÆåÊàê: ${total} „ÉÅ„É£„É≥„ÇØÁµêÂêà`);
        renderProgress();
        updateProgressBar();
        showToast("üéâ ÂÖ®„ÉÅ„É£„É≥„ÇØÂèó‰ø°ÂÆå‰∫ÜÔºÅ");
      }

      function decodeBase64Url(b64url) {
        const padLength = (4 - (b64url.length % 4)) % 4;
        const padded = b64url + "=".repeat(padLength);
        const b64 = padded.replace(/-/g, "+").replace(/_/g, "/");
        try {
          const decoded = atob(b64);
          const bytes = new Uint8Array(decoded.length);
          for (let i = 0; i < decoded.length; i++) {
            bytes[i] = decoded.charCodeAt(i);
          }
          const decoder = new TextDecoder('utf-8');
          return decoder.decode(bytes);
        } catch (err) {
          status("„Éá„Ç≥„Éº„ÉâÂ§±Êïó: " + err.message);
          return "";
        }
      }

      function status(msg) {
        statusEl.textContent = msg;
      }

      function addRecent(raw, chunk) {
        const shortRaw = raw.length > 30 ? raw.substring(0, 30) + "..." : raw;
        recentItems.unshift(
          `ID: ${chunk.messageId} [${chunk.index}/${chunk.total}]`
        );
        if (recentItems.length > 5) recentItems.pop();
        renderRecent();
        renderProgress();
      }

      function renderRecent() {
        recentEl.innerHTML = "";
        if (!recentItems.length) {
          recentEl.innerHTML = "<li>„Åæ„Å†Âèó‰ø°„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì</li>";
          return;
        }
        recentItems.forEach((txt) => {
          const li = document.createElement("li");
          li.textContent = txt;
          recentEl.appendChild(li);
        });
      }

      function renderProgress() {
        if (!session) {
          progressEl.textContent = "Êú™Âèó‰ø°";
          return;
        }
        const { messageId, total, received } = session;
        const pending = total - received.size;
        const missingList = [];
        for (let i = 0; i < total; i += 1) {
          if (!received.has(i)) missingList.push(i);
        }
        progressEl.innerHTML = "";
        const item = document.createElement("div");
        item.className = "progress-item";
        
        const shortId = messageId.length > 12 ? 
          messageId.substring(0, 12) + "..." : messageId;
        
        item.innerHTML = `
          <div><strong>ID:</strong> ${shortId}</div>
          <div><strong>ÈÄ≤Êçó:</strong> ${received.size}/${total} (ÊÆã${pending})</div>
          ${missingList.length ? `<div><strong>Êú™Âèó‰ø°:</strong> ${missingList.join(", ")}</div>` : ''}
        `;
        progressEl.appendChild(item);
      }

      startBtn.addEventListener("click", start);
      stopBtn.addEventListener("click", stop);
      clearBtn.addEventListener("click", clearOutput);
      copyBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(outputEl.value);
          status("„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü");
        } catch (err) {
          outputEl.select();
          document.execCommand('copy');
          status("„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü");
        }
      });

      window.addEventListener("beforeunload", stop);
      
      // ÂàùÊúüÂåñ
      setupDetector().catch(console.error);
    </script>
  </body>
</html>
